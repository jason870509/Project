<!DOCTYPE html>

<html>

<head>
  <style>
    #info {
      position: absolute;
      top: 0px;
      width: 100%;
      padding: 10px;
      text-align: center;
      color: #ffff00
    }

    body {
      overflow: hidden;
    }
  </style>
</head>

<body>

  <div id="info">hw4 walking</div>


  <script src="https://threejs.org/build/three.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  <script src="https://jyunming-chen.github.io/game3js/js/ccdsys.js"></script>
  <script src="https://raw.githack.com/jyunming-chen/game3js/master/js/ccdbox.js"></script>
  <script src="https://rawgit.com/jyunming-chen/tutsplus/master/js/text2D.js"></script>
  <script src="js/Gyroscope.js"></script>

  <script>

    // import * as THREE from "https://threejs.org/build/three.module.js";
    // import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

    const LS = 5.3, L2 = 5.2, L1 = 4.8, Lh = 3.3, Hh = 8.3;
    var axes = [];
    var joints = new THREE.Vector3();
    var first = 1;
    var mouse = new THREE.Vector2();
    var target = new THREE.Vector3();
    var pickPlane, raycaster;
    var theta1 = 0, theta2 = 0;

    class TwoLinkLeg {

      constructor() {
        this.theta1 = 0;
        this.theta2 = 0;
      }


      init() {
        var material = new THREE.MeshPhongMaterial({
          color: 0xff00ff
        });
        let body = new THREE.Object3D();

        this.thigh = new THREE.Object3D();
        let thighMesh = new THREE.Mesh(new THREE.BoxGeometry(1, L2, 1), material)
        thighMesh.castShadow = true;
        thighMesh.receiveShadow = true;
        this.thigh.add(thighMesh)
        thighMesh.position.y = -L2 / 2
        body.add(this.thigh)

        this.leg = new THREE.Object3D()
        let legMesh = new THREE.Mesh(new THREE.BoxGeometry(1, L1, 1), material)
        legMesh.castShadow = true;
        legMesh.receiveShadow = true;
        this.leg.add(legMesh)
        legMesh.position.y = -L1 / 2
        this.leg.position.y = -L2
        this.thigh.add(this.leg)

        this.torso = new THREE.Object3D();
        let torsoMesh = new THREE.Mesh(new THREE.BoxGeometry(1, Lh, 1), material)
        torsoMesh.castShadow = true;
        torsoMesh.receiveShadow = true;
        this.torso.add(torsoMesh)
        torsoMesh.position.y = Lh / 2
        body.add(this.torso)

        return body;
      }

      update(thetas) {
        this.theta1 = thetas[0]
        this.theta2 = thetas[1]
        this.thigh.rotation.z = this.theta1
        this.leg.rotation.z = this.theta2
      }
    }

    var camera, scene, renderer;
    var clock = new THREE.Clock();
    var body;

    init();
    animate();

    function fk(theta, joints) {
      /*
        // 不能這樣做，因為還在迭代階段，並沒有render
        joints[0] = new THREE.Vector3();
        joints[1] = link1.localToWorld (new THREE.Vector3(60,0,0))
        joints[2] = link2.localToWorld (new THREE.Vector3(90,0,0))
      */

      joints[0] = new THREE.Vector3(0, 0, 0);

      var m = new THREE.Matrix4();
      m.makeRotationY(theta[0]);
      m.multiply(new THREE.Matrix4().makeTranslation(0, -60, 0));
      var localzero = new THREE.Vector3(0, 0, 0);
      localzero.applyMatrix4(m);
      joints[1].copy(localzero);

      m.multiply(new THREE.Matrix4().makeRotationY(theta[1]));
      m.multiply(new THREE.Matrix4().makeTranslation(0, -90, 0));
      localzero.set(0, 0, 0);
      localzero.applyMatrix4(m);
      joints[2].copy(localzero);

    }



    function setarm() {
      var axis = new CCD_axis(new THREE.Vector3(0, 0, 1), 0);
      // axis.limits = new THREE.Vector2(-3.14, 3.14);
      axes.push(axis);

      var axis = new CCD_axis(new THREE.Vector3(0, 0, 1), 1);
      axis.limits = new THREE.Vector2(-3, 0);
      axes.push(axis);
    }


    function init() {
      scene = new THREE.Scene();

      let loader = new THREE.TextureLoader();
      loader.crossOrigin = '';
      texture = loader.load('https://i.imgur.com/p8CRm9W.jpg');

      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
      camera.position.z = 50;

      var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
      //scene.add(gridXZ);
      var floor = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshPhongMaterial({
        map: texture,
        side: THREE.DoubleSide
      }));
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(20, 20);
      floor.rotation.x = -Math.PI / 2
      scene.add(floor)

      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x888888);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFShadowMap;
      scene.add(new THREE.AmbientLight(0x222222));

      let controls = new THREE.OrbitControls(camera, renderer.domElement);
      document.body.appendChild(renderer.domElement);

      pickPlane = new THREE.Mesh(new THREE.PlaneGeometry(600, 600), new THREE.MeshBasicMaterial());
      //pickPlane.rotation.x = -Math.PI / 2;
      scene.add(pickPlane);
      //REF: https://github.com/mrdoob/three.js/issues/7551
      //pickPlane.visible = true;
      pickPlane.material.visible = true;

      raycaster = new THREE.Raycaster();


      ///////////////////////////////////////////////////////////
      //set body
      bodyLink = new TwoLinkLeg();
      body = bodyLink.init();
      scene.add(body)
      body.position.y = Hh;

      bodyLink2 = new TwoLinkLeg();
      body2 = bodyLink2.init();
      scene.add(body2)
      body2.position.z = 1;
      body2.position.y = Hh;

      link1 = makeLink(60);
      scene.add(link1);
      link2 = makeLink(90);
      link1.add(link2);
      link2.position.set(0, 60, 0);
      //////////////////////////////////////
      //set ccdSys
      // bodyLink.ccdSys = new CCDSys(fk)
      // bodyLink.ccdSys.setCCDAxis(new THREE.Vector3(0, 0, 1), 0)
      // bodyLink.ccdSys.setCCDAxis(new THREE.Vector3(0, 0, 1), 1, -3, 0)
      bodyLink.target = new THREE.Vector3();

      // bodyLink2.ccdSys = new CCDSys(fk)
      // bodyLink2.ccdSys.setCCDAxis(new THREE.Vector3(0, 0, 1), 0)
      // bodyLink2.ccdSys.setCCDAxis(new THREE.Vector3(0, 0, 1), 1, -3, 0)
      bodyLink2.target = new THREE.Vector3();

      for (var i = 0; i < 3; i++)
        joints[i] = new THREE.Vector3();


      //////////////////////////////////////////////////
      //set Gyro
      gyro = new THREE.Gyroscope();
      scene.add(gyro)
      gyro.add(camera)
      body.add(gyro)

      /////////////////////////////////////////////////////////
      // spotlight
      light = new THREE.SpotLight(0xffffff, 1.5);
      light.position.set(0, 40, 80);
      light.angle = Math.PI / 3;
      light.penumbra = 0.5;
      gyro.add(light);
      light.target = body;

      // shadow map settings
      light.castShadow = true;
      light.shadow.mapSize.width = 4096;
      light.shadow.mapSize.height = 4096;
      light.shadow.camera.near = 1;
      light.shadow.camera.far = 800;
      light.shadow.camera.fov = light.angle / Math.PI * 180 * 2;

      floor.receiveShadow = true;
      // var Text2D = THREE_Text.MeshText2D;
      //var textAlign = THREE_Text.textAlign;

      /////////////////////////////////////////////////////////
      // text
      // text = new Text2D("走平面", {
      //   align: textAlign.center,
      //   fillStyle: '#00ffff',
      //   antialias: false
      // });
      //gyro.add(text)
      //text.position.y = 20
      //text.scale.set(0.1, 0.1, 0.1);
      setarm();

      window.addEventListener('resize', onWindowResize, false);
      window.addEventListener('mousemove', onDocumentMouseMove, false);
    }

    function makeLink(length) {
      var oneLink = new THREE.Object3D();
      var mesh = new THREE.Mesh(new THREE.BoxGeometry(10, length, 10), new THREE.MeshNormalMaterial());
      oneLink.add(mesh);
      mesh.position.set(0, length / 2, 0);
      return oneLink;
    }

    function onDocumentMouseMove(event) {
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      var intersects = raycaster.intersectObjects([pickPlane]);

      if (intersects.length > 0) {
        target.copy(intersects[0].point);
      }
    }

    function onWindowResize() {
      var width = window.innerWidth;
      var height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    function animate() {
      thetaGroin = 0.31
      thetaKnee = 0.6

      bodyLink.thigh.rotation.z = thetaGroin
      bodyLink.leg.rotation.z = -thetaKnee;
      bodyLink2.leg.rotation.z = -thetaKnee;
      bodyLink2.thigh.rotation.z = thetaGroin

      requestAnimationFrame(animate);
      render();
    }

    function render() {
      update();
      renderer.render(scene, camera);
    }

    var x1 = 0, x2 = 5.3, y1 = 0, y2 = 0, dt = 0;

    function update() {
      var thetas; // for call-by-reference
      var torsoTarget1, torsoTarget2, walkTarget1, walkTarget2;
      var Ts = 1;
      var time = clock.getElapsedTime();
      dt += time;
      var V = 5.3 / Ts;
      var n = Math.floor(dt / Ts);
      var tt = dt % Ts;

      //console.log()
      torsoTarget1 = new THREE.Vector3(5.3 / 2 + 5.3 * dt / Ts, 8.3 - 0.6 / 2 * Math.cos(2 * Math.PI * dt / Ts) + 0.5, 0);
      torsoTarget2 = new THREE.Vector3(5.3 / 2 + 5.3 * dt / Ts, 8.3 - 0.6 / 2 * Math.cos(2 * Math.PI * dt / Ts) + 0.5, 1);
      //body.position.copy(torsoTarget1)
      //body2.position.copy(torsoTarget2)

      if (n % 2 === 0) {
        x1 += 2 * V * time
        y1 = 1 / 2 - 1 / 2 * Math.cos(2 * Math.PI * tt / (Ts))
      } else {
        x2 += 2 * V * time
        y2 = 1 / 2 - 1 / 2 * Math.cos(2 * Math.PI * tt / (Ts));
      }


      // bodyLink.ccdSys.solve(bodyLink.target, thetas);
      // if (first) {
      //   walkTarget1 = new THREE.Vector3(x1, y1, 0);
      //   body.worldToLocal(walkTarget1);
      //   console.log(bodyLink.target)
      //   thetas = [bodyLink.theta1, bodyLink.theta2];
      //   // console.log(thetas)
      //   bodyLink.target.copy(walkTarget1);
      //   // console.log(bodyLink.target)
      //   console.log("first: ", thetas);
      //   ik_ccd(bodyLink.target, thetas);
      //   console.log("second: ", thetas);

      //   bodyLink.update(thetas);
      //   first = 0;
      // }

      //bodyLink2.ccdSys.solve(bodyLink2.target, thetas);

      // thetas = [bodyLink2.theta1, bodyLink2.theta2];
      // walkTarget2 = new THREE.Vector3(0, y2, 1);
      // body2.worldToLocal(walkTarget2);
      // bodyLink2.target.copy(walkTarget2);
      // thetas = [bodyLink2.theta1, bodyLink2.theta2];
      // ik_ccd(bodyLink2.target, thetas);
      // bodyLink2.update(thetas);
      // console.log("second: ", thetas);
      // clock.start();

      // controls.update();

      // var theta = [bodyLink2.theta1, bodyLink2.theta2]; // for call-by-reference

      // // ik_ccd works on the theta array
      // ik_ccd(target, theta);

      // // copy the theta array to theta1 & theta2
      // //theta1 = theta[0], theta2 = theta[1];
      // bodyLink2.update(theta);
      var theta = [theta1, theta2]; // for call-by-reference

      // ik_ccd works on the theta array
      ik_ccd(target, theta);

      // copy the theta array to theta1 & theta2
      theta1 = theta[0], theta2 = theta[1];
      link1.rotation.y = theta1;
      link2.rotation.y = theta2;
    }

  </script>
</body>

</html>